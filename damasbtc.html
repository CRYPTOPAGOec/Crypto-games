<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Damas (Crypto Oro Edition)</title>

    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(to bottom right, #a0a0a0, #e0e0e0); /* Degradado suave de fondo */
            margin: 0;
            padding: 20px;
            box-sizing: border-box; /* Incluir padding en el tamaño total */
        }

        #game-container {
            background-color: #fff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #333;
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        }

        #status {
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: bold;
            color: #555;
            min-height: 1.5em; /* Evitar que el layout salte al cambiar texto */
            text-align: center;
        }

        #board-wrapper {
            border: 8px solid #8b4513; /* Borde de madera oscuro */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            overflow: hidden; /* Asegura que las esquinas redondeadas se vean bien */
            margin-left: auto;
            margin-right: auto;
        }


        #board {
            display: grid;
            grid-template-columns: repeat(8, minmax(45px, 65px)); /* Ajustar tamaño para que quepa el texto */
            grid-template-rows: repeat(8, minmax(45px, 65px));    /* Ajustar tamaño para que quepa el texto */
            width: 100%; /* Ocupa el ancho del wrapper */
            height: auto; /* Altura se ajusta */
            max-width: 520px; /* Tamaño máximo ajustado */
            max-height: 520px;
        }

        .square {
            width: 100%; /* Ocupa el 100% de la celda del grid */
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none; /* Evitar selección de texto */
            transition: background-color 0.2s ease; /* Transición suave para el resaltado */
            box-sizing: border-box; /* Incluir padding/border en el tamaño */
        }

        .square.light {
            background-color: #f0d9b5; /* Color claro de tablero */
        }

        .square.dark {
            background-color: #b58863; /* Color oscuro de tablero */
        }

        /* Resaltado de movimientos */
        .square.possible-move {
            background-color: rgba(100, 255, 100, 0.6); /* Verde semi-transparente */
            box-shadow: inset 0 0 12px rgba(0, 255, 0, 0.9);
        }

        /* Resaltado de capturas */
        .square.possible-capture {
             background-color: rgba(255, 100, 100, 0.6); /* Rojo semi-transparente */
             box-shadow: inset 0 0 12px rgba(255, 0, 0, 0.9);
        }

        /* Efecto hover en casillas interactivas */
        .square.dark:not(:has(.piece)):hover, /* Casillas oscuras vacías */
        .square:has(.piece.red):hover, /* Piezas rojas (humanas) */
        .square.possible-move:hover,
        .square.possible-capture:hover {
            filter: brightness(1.1); /* Aclarar ligeramente al pasar el ratón */
        }


        .piece {
            width: 90%; /* Ajustar tamaño para que quepa el texto */
            height: 90%;
            border-radius: 8px; /* Bordes ligeramente redondeados */
            box-sizing: border-box;
            position: relative;
            display: flex; /* Para centrar el texto */
            flex-direction: column; /* Apilar texto y "KING" */
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Permitir clics a través de la pieza */
            /* Sutil efecto 3D */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); /* Sombra más suave para forma no redonda */
            transition: transform 0.1s ease, border-color 0.2s ease; /* Transición suave */
            font-size: 0.7em; /* Tamaño de fuente para que quepa */
            font-weight: bold;
            overflow: hidden; /* Asegurar que el texto largo no se desborde */
            padding: 2px; /* Pequeño padding interno */
            text-align: center; /* Centrar texto */
            line-height: 1.2; /* Espacio entre líneas */
        }

        /* --- Estilo para las piezas Rojas (Ahora Doradas) --- */
        .piece.red {
            background: linear-gradient(to bottom, #FFD700, #FFA500); /* Degradado de oro */
            border: 2px solid #B8860B; /* Darkgoldenrod para el borde */
            color: #4B3B02; /* Texto marrón oscuro para contraste */
            text-shadow: 1px 1px 0px rgba(255, 255, 255, 0.5); /* Sombra clara */
        }

        /* Estilo para las piezas Negras (ETHEREUM) */
        .piece.black {
            background-color: #667deb; /* Color azul/morado de Ethereum */
            border: 2px solid #4c5cd6;
            color: white; /* Texto blanco en azul */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); /* Sombra para mejor legibilidad */
        }

        /* Estilo para la pieza seleccionada por el humano */
        .piece.selected {
            border-color: cyan; /* Cambiar el borde de selección a cian para que destaque sobre el oro */
            border-width: 3px;
            transform: scale(1.05); /* Agranda ligeramente */
            box-shadow: 0 0 10px cyan, 0 2px 4px rgba(0, 0, 0, 0.3); /* Resplandor cian + sombra */
        }

        /* Estilo para la palabra "KING" */
        .piece .king-text {
            font-size: 0.8em; /* Tamaño ligeramente más pequeño */
            font-weight: bold;
            /* color: inherit;  KING hereda el color del texto de la pieza */
            /* text-shadow: inherit; KING hereda la sombra del texto de la pieza */
            margin-top: 2px; /* Pequeño espacio sobre el texto principal */
        }


        #reset-button {
            margin-top: 25px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #5cb85c; /* Verde para reiniciar */
            color: white;
            border: none;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }

        #reset-button:hover {
            background-color: #4cae4c;
        }

        /* Estilo para el tablero cuando la IA está pensando */
        .computer-thinking {
            pointer-events: none; /* Deshabilita clics */
            opacity: 0.7; /* Hace el tablero un poco transparente */
        }

        /* Clases temporales para visualización de movimiento de IA (opcional) */
        .square.ai-move-start,
        .square.ai-move-end {
            background-color: rgba(255, 255, 0, 0.6); /* Amarillo semi-transparente */
            box-shadow: inset 0 0 12px rgba(255, 255, 0, 0.9);
        }


        /* Responsive básico */
        @media (max-width: 550px) { /* Ajustar el breakpoint si cambias max-width del tablero */
            #board {
                grid-template-columns: repeat(8, minmax(38px, 1fr)); /* Columnas más pequeñas */
                grid-template-rows: repeat(8, minmax(38px, 1fr));
                max-width: 360px; /* Tamaño máximo más pequeño */
                max-height: 360px;
            }

            .piece {
                font-size: 0.6em; /* Tamaño de fuente ajustado */
            }

            .piece .king-text {
                font-size: 0.7em; /* Tamaño de KING ajustado */
            }

            h1 {
                font-size: 1.6em;
            }

            #status {
                font-size: 1em;
            }
            #game-container {
                padding: 15px;
            }
        }
    </style>
<style type="text/css">
.grande { font-size: 60px; }
</style>
<script>
// Escribir aqui el código Javascript
</script>
</head>
<body>

    <div id="game-container">
        <h1>Juego de Damas</h1>
        <div id="status"></div> <div id="board-wrapper">
             <div id="board"></div>
        </div>
        <button id="reset-button">Reiniciar Juego</button>
    </div>

    <script>
        const board = document.getElementById('board');
        const statusDisplay = document.getElementById('status');
        const resetButton = document.getElementById('reset-button');
        const boardWrapper = document.getElementById('board-wrapper'); // Wrapper para deshabilitar clics


        // Representación del tablero: 8x8 array
        // null: casilla vacía
        // 'red': ficha roja normal (Jugador Humano - BITCOIN - Color Dorado)
        // 'black': ficha negra normal (Computador - ETHEREUM - Color Azul)
        // 'red-king': dama roja
        // 'black-king': dama negra
        let boardState = [];

        let currentPlayer = 'red'; // Empiezan las rojas (Jugador Humano - Doradas/BITCOIN)
        let selectedPiece = null; // { row: r, col: c } de la pieza seleccionada por el humano
        let possibleMoves = []; // Array de { startRow, startCol, endRow, endCol, capturedRow, capturedCol } de destinos válidos

        let isComputerThinking = false; // Bandera para evitar clics durante el turno del computador

        const COMPUTER_TURN_DELAY = 800; // Milisegundos de retardo antes de que el computador elija y haga un movimiento
        const COMPUTER_MOVE_DELAY = 300; // Milisegundos de retardo visual para cada paso del movimiento/captura del computador


        // --- Inicialización del juego ---
        function initializeBoard() {
            boardState = [
                [null, 'black', null, 'black', null, 'black', null, 'black'],
                ['black', null, 'black', null, 'black', null, 'black', null],
                [null, 'black', null, 'black', null, 'black', null, 'black'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['red', null, 'red', null, 'red', null, 'red', null],
                [null, 'red', null, 'red', null, 'red', null, 'red'],
                ['red', null, 'red', null, 'red', null, 'red', null]
            ];
            currentPlayer = 'red';
            selectedPiece = null;
            possibleMoves = [];
            isComputerThinking = false; // Asegurarse de que no está pensando al inicio
            boardWrapper.classList.remove('computer-thinking'); // Asegurarse de que el tablero está habilitado
            renderBoard();
            updateStatus();
            console.log("Juego reiniciado. Turno: Doradas (BITCOIN)");
        }

        // --- Renderizar el tablero en HTML (Actualiza solo lo necesario) ---
        function renderBoard() {
            // Si el tablero no existe en el DOM, lo creamos por primera vez
            if (board.children.length === 0) {
                 for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.classList.add('square');
                        square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                        square.dataset.row = r;
                        square.dataset.col = c;
                         // Añadir evento click a cada casilla
                        square.addEventListener('click', handleClick);
                        board.appendChild(square);
                    }
                }
            }

            // Actualizar el contenido de cada casilla según el boardState
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = board.children[r * 8 + c];
                    const piece = boardState[r][c];
                    let pieceElement = square.querySelector('.piece'); // Buscar pieza existente en el HTML

                    if (piece) { // Si hay una pieza en el estado
                        const playerColor = piece.split('-')[0]; // 'red' o 'black'
                        const isKing = piece.includes('king');
                        const pieceText = playerColor === 'red' ? 'BITCOIN' : 'ETHEREUM';
                        // Usamos innerHTML para poder tener la palabra KING en un span si quieres estilizarla diferente
                        const pieceHTML = isKing ? `${pieceText}<span class="king-text">KING</span>` : pieceText;


                        if (!pieceElement) { // Y no hay elemento HTML de pieza, crearlo
                            pieceElement = document.createElement('div');
                            pieceElement.classList.add('piece');
                            pieceElement.classList.add(playerColor); // 'red' o 'black'
                             square.appendChild(pieceElement);
                        } else {
                             // Si ya existe, asegurar que tiene las clases correctas de color
                             if (!pieceElement.classList.contains(playerColor)) {
                                  pieceElement.classList.remove('red', 'black');
                                  pieceElement.classList.add(playerColor);
                             }
                        }

                         // Actualizar clase 'king'
                         if (isKing && !pieceElement.classList.contains('king')) {
                             pieceElement.classList.add('king');
                         } else if (!isKing && pieceElement.classList.contains('king')) {
                             pieceElement.classList.remove('king');
                         }
                         // Actualizar el contenido HTML
                         pieceElement.innerHTML = pieceHTML;


                    } else { // Si no hay pieza en el estado
                        if (pieceElement) { // Y hay un elemento HTML de pieza, eliminarlo
                            square.removeChild(pieceElement);
                        }
                    }
                }
            }

            // Después de actualizar las piezas, actualizar los resaltados (solo para el humano)
            highlightPossibleMoves();
            highlightSelectedPiece();
        }

        // --- Manejar clics en el tablero (Solo para el jugador humano) ---
        function handleClick(event) {
            // Ignorar clics si no es el turno del jugador humano o el computador está pensando
            if (currentPlayer !== 'red' || isComputerThinking) {
                // console.log("No es tu turno o el computador está pensando.");
                return;
            }

            const square = event.target.closest('.square');
            if (!square) return;

            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            const piece = boardState[row][col];

            // 1. Si no hay pieza seleccionada: Intentar seleccionar una pieza del jugador humano
            if (!selectedPiece) {
                if (piece && piece.includes(currentPlayer)) {
                    selectedPiece = { row: row, col: col };
                    // Recalcular possibleMoves basándose en la pieza seleccionada y si hay capturas obligatorias GLOBALES
                    const allLegalPlayerMoves = findAllLegalMovesForPlayer(currentPlayer);
                    possibleMoves = allLegalPlayerMoves.filter(move => move.startRow === row && move.startCol === col); // Filtra solo los movimientos de la pieza clickeada

                    if (possibleMoves.length > 0) {
                        renderBoard(); // Actualizar para mostrar selección y movimientos posibles
                    } else {
                        selectedPiece = null; // Deseleccionar si no hay movimientos posibles para ESA pieza
                        console.log("Esta pieza no puede moverse.");
                    }
                }
            }
            // 2. Si ya hay una pieza seleccionada: Intentar mover a la casilla clickeada
            else {
                // Buscar si la casilla clickeada es uno de los movimientos posibles CALCULADOS previamente
                const move = possibleMoves.find(m => m.endRow === row && m.endCol === col);

                if (move) {
                    // Es un movimiento válido para la pieza seleccionada
                    const captured = movePiece(selectedPiece.row, selectedPiece.col, move.endRow, move.endCol, move.capturedRow, move.capturedCol); // Corregido typo: move.col -> move.capturedCol

                    // Después de mover/capturar, verificar si hay más capturas posibles para la misma pieza (chain capture)
                    const nextCaptures = getPossibleCaptures(move.endRow, move.endCol); // Buscar capturas desde la nueva posición

                    // Siempre deseleccionar y limpiar movimientos después de intentar un movimiento
                    selectedPiece = null;
                    possibleMoves = [];

                    if (captured && nextCaptures.length > 0) {
                         // Hubo captura y hay más capturas posibles para la misma pieza (chain capture)
                         selectedPiece = { row: move.endRow, col: move.endCol }; // Mantener la pieza "lógicamente" seleccionada para la cadena
                         possibleMoves = nextCaptures; // Mostrar solo las siguientes capturas posibles
                         renderBoard(); // Actualizar para mostrar la pieza en la nueva posición y las nuevas capturas
                         // El turno NO cambia, el jugador debe seguir capturando con esta pieza
                         console.log("Captura en cadena disponible.");
                    } else {
                        // No hubo captura O no hay más capturas en cadena
                        renderBoard(); // Actualizar visual final del turno del jugador
                        if (!checkWinCondition()) { // Si el juego no ha terminado
                            switchTurn(); // Cambiar al turno del computador
                        }
                    }

                } else {
                    // No es un movimiento válido para la pieza seleccionada (el jugador clickeó otra cosa)
                    // Deseleccionar la pieza actual
                    selectedPiece = null;
                    possibleMoves = [];
                    renderBoard(); // Actualizar para quitar la selección y los posibles movimientos
                     // Si el usuario hizo clic en otra pieza del jugador actual, seleccionarla (comienza un nuevo intento de movimiento)
                    if (piece && piece.includes(currentPlayer)) {
                         selectedPiece = { row: row, col: col };
                         // Recalcular possibleMoves para la nueva pieza seleccionada
                         const allLegalPlayerMoves = findAllLegalMovesForPlayer(currentPlayer);
                         possibleMoves = allLegalPlayerMoves.filter(move => move.startRow === row && move.startCol === col);

                         if (possibleMoves.length > 0) {
                             renderBoard(); // Actualizar para mostrar la nueva selección y movimientos
                         } else {
                            selectedPiece = null; // Deseleccionar si no hay movimientos
                         }
                     }
                }
            }
        }

        // --- Obtener movimientos posibles para UNA pieza (simples y capturas) ---
        // Usado internamente para calcular `findAllLegalMovesForPlayer`. NO aplica la regla global de captura obligatoria.
        // Devuelve un array de objetos { startRow, startCol, endRow, endCol, capturedRow, capturedCol }
        function getMovesForPiece(r, c) {
            const piece = boardState[r][c];
            if (!piece) return [];

            const isKing = piece.includes('king');
            const player = piece.split('-')[0];
            const opponent = player === 'red' ? 'black' : 'red';
            let moves = [];

            // Direcciones de movimiento simple (siempre de a 1 casilla)
             let moveDirections = [];
            if (player === 'red' || isKing) { // Rojas se mueven hacia arriba (filas menores)
                moveDirections.push({ dr: -1, dc: -1 }); // Diagonal arriba-izquierda
                moveDirections.push({ dr: -1, dc: 1 });  // Diagonal arriba-derecha
            }
            if (player === 'black' || isKing) { // Negras se mueven hacia abajo (filas mayores)
                moveDirections.push({ dr: 1, dc: -1 }); // Diagonal abajo-izquierda
                moveDirections.push({ dr: 1, dc: 1 });  // Diagonal abajo-derecha
            }

            for (const dir of moveDirections) {
                const newR = r + dir.dr;
                const newC = c + dir.dc;

                // Verificar si la nueva posición está dentro del tablero
                if (newR >= 0 && newR < 8 && newC >= 0 && newC < 8) {
                    // Verificar si la casilla de destino está vacía
                    if (boardState[newR][newC] === null) {
                         // Es un movimiento simple válido
                         moves.push({ startRow: r, startCol: c, endRow: newR, endCol: newC, capturedRow: null, capturedCol: null });
                    }
                }
            }

            // --- Buscar Capturas para esta pieza ---
             moves = moves.concat(getPossibleCaptures(r, c));

            return moves;
        }


        // --- Obtener SÓLO capturas posibles para UNA pieza ---
        // Devuelve un array de objetos { startRow, startCol, endRow, endCol, capturedRow, capturedCol }
        function getPossibleCaptures(r, c) {
             const piece = boardState[r][c];
             if (!piece) return [];

             const isKing = piece.includes('king');
             const player = piece.split('-')[0];
             const opponent = player === 'red' ? 'black' : 'red';
             let captures = [];

             // Direcciones de salto (siempre de a 2 casillas)
             const captureDirections = [
                 { dr: -1, dc: -1 }, { dr: -1, dc: 1 },
                 { dr: 1, dc: -1 }, { dr: 1, dc: 1 }
             ];

             for (const dir of captureDirections) {
                 const intermediateR = r + dir.dr; // Fila de la posible pieza a capturar
                 const intermediateC = c + dir.dc; // Columna de la posible pieza a capturar
                 const endR = r + dir.dr * 2;       // Fila de la casilla de destino después del salto
                 const endC = c + dir.dc * 2;       // Columna de la casilla de destino después del salto

                 // Verificar si la casilla de destino y la intermedia están dentro del tablero
                 if (endR >= 0 && endR < 8 && endC >= 0 && endC < 8 &&
                     intermediateR >= 0 && intermediateR < 8 && intermediateC >= 0 && intermediateC < 8) {

                     const intermediatePiece = boardState[intermediateR][intermediateC];
                     const endSquare = boardState[endR][endC];

                     // Verificar si la casilla intermedia tiene una pieza del oponente
                     // Y si la casilla de destino está vacía
                     if (intermediatePiece && intermediatePiece.includes(opponent) && endSquare === null) {
                          // Es una captura posible
                          // Para piezas normales, la captura solo es hacia adelante en su dirección inicial
                          if (!isKing) {
                              if ((player === 'red' && dir.dr === -1) || (player === 'black' && dir.dr === 1)) {
                                   captures.push({
                                       startRow: r, startCol: c,
                                       endRow: endR, endCol: endC,
                                       capturedRow: intermediateR,
                                       capturedCol: intermediateC
                                   });
                               }
                          } else {
                               // Los reyes pueden capturar en cualquier dirección diagonal
                               captures.push({
                                   startRow: r, startCol: c,
                                   endRow: endR, endCol: endC,
                                   capturedRow: intermediateR,
                                   capturedCol: intermediateC
                               });
                          }
                     }
                 }
             }
         }
         return captures;
        }


        // --- Obtener TODOS los movimientos legales para un jugador (para IA y checkWinCondition) ---
        // Devuelve un array plano de TODOS los movimientos posibles, priorizando capturas globales.
        function findAllLegalMovesForPlayer(player) {
             let allCaptures = [];
             let allSimpleMoves = [];

             for (let r = 0; r < 8; r++) {
                 for (let c = 0; c < 8; c++) {
                     const piece = boardState[r][c];
                     if (piece && piece.includes(player)) {
                         // Obtener capturas para esta pieza
                         const pieceCaptures = getPossibleCaptures(r, c);
                         allCaptures = allCaptures.concat(pieceCaptures);

                         // Si no hay capturas para esta pieza, obtener movimientos simples
                         if (pieceCaptures.length === 0) {
                             const isKing = piece.includes('king');
                             let moveDirections = [];
                             // Direcciones de movimiento simple (siempre de a 1 casilla)
                             if (player === 'red' || isKing) {
                                 moveDirections.push({ dr: -1, dc: -1 }); // Diagonal arriba-izquierda
                                 moveDirections.push({ dr: -1, dc: 1 });  // Diagonal arriba-derecha
                             }
                             if (player === 'black' || isKing) {
                                 moveDirections.push({ dr: 1, dc: -1 }); // Diagonal abajo-izquierda
                                 moveDirections.push({ dr: 1, dc: 1 });  // Diagonal abajo-derecha
                             }
                             for (const dir of moveDirections) {
                                 const newR = r + dir.dr;
                                 const newC = c + dir.dc;
                                 if (newR >= 0 && newR < 8 && newC >= 0 && newC < 8 && boardState[newR][newC] === null) {
                                     allSimpleMoves.push({ startRow: r, startCol: c, endRow: newR, endCol: newC, capturedRow: null, capturedCol: null });
                                 }
                             }
                         }
                     }
                 }
             }

             // Si hay CUALQUIER captura posible para el jugador, solo se permiten capturas
             if (allCaptures.length > 0) {
                 return allCaptures;
             } else {
                 // Si no hay capturas, se permiten todos los movimientos simples
                 return allSimpleMoves;
             }
        }


        // --- Realizar el movimiento de la pieza (actualiza el boardState) ---
        // NO renderiza ni cambia el turno ni verifica la victoria aquí.
        // Devuelve true si hubo captura, false si fue un movimiento simple
        function movePiece(startR, startC, endR, endC, capturedR, capturedC) {
            const piece = boardState[startR][startC];

            // Mover la pieza en el estado
            boardState[endR][endC] = piece;
            boardState[startR][startC] = null;

            let captured = false;
            // Si hubo captura, eliminar la pieza capturada del estado
            if (capturedR !== null && capturedC !== null) {
                boardState[capturedR][capturedC] = null;
                captured = true;
                // console.log(`${piece.split('-')[0]} capturó pieza en ${capturedR},${capturedC} moviendo a ${endR},${endC}`);
            } else {
                 // console.log(`${piece.split('-')[0]} movió de ${startR},${startC} a ${endR},${endC}`);
            }

            // Verificar si la pieza llega al final y se convierte en dama (actualiza el estado)
            checkPromotion(endR, endC);

            return captured;
        }

        // --- Verificar y realizar la coronación a Dama (actualiza el boardState) ---
        function checkPromotion(row, col) {
            const piece = boardState[row][col];
            if (!piece || piece.includes('king')) return; // Ya es rey o no hay pieza

            const player = piece.split('-')[0];

            // Las rojas coronan en la fila 0, las negras en la fila 7
            if ((player === 'red' && row === 0) || (player === 'black' && row === 7)) {
                boardState[row][col] = player + '-king';
                console.log(`${player} se corona Dama!`);
                // La actualización visual ocurrirá en renderBoard
            }
        }


        // --- Cambiar el turno ---
        function switchTurn() {
            currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
            updateStatus();

            // Si el juego no ha terminado, manejar el turno del computador si le toca
            if (!checkWinCondition()) {
                if (currentPlayer === 'black') {
                    console.log("Es turno del computador (ETHEREUM)");
                    isComputerThinking = true; // El computador va a pensar
                    boardWrapper.classList.add('computer-thinking'); // Deshabilitar interacción visualmente
                    // Pequeño retardo antes de que el computador haga su movimiento
                    setTimeout(makeComputerMove, COMPUTER_TURN_DELAY);
                } else {
                     console.log("Es turno del jugador (BITCOIN)");
                     isComputerThinking = false; // El jugador es el que piensa :)
                     boardWrapper.classList.remove('computer-thinking'); // Habilitar interacción
                     // No hacemos nada más, el juego espera el clic del humano (controlado por handleClick)
                }
            } else {
                 // Si el juego terminó, asegurar que el tablero esté deshabilitado
                 boardWrapper.classList.add('computer-thinking');
            }
        }

        // --- Actualizar el texto de estado ---
        function updateStatus() {
            if (checkWinCondition()) {
                // El texto de victoria ya se establece en checkWinCondition
                return;
            }
            let playerName = '';
            if (currentPlayer === 'red') {
                // Cambiado de 'Rojas' a 'Doradas'
                playerName = 'Doradas (BITCOIN - Tu turno)';
            } else {
                playerName = 'ETHEREUM (Turno del Computador)';
                if (isComputerThinking) {
                    playerName = 'ETHEREUM (Computador pensando...)';
                }
            }
            statusDisplay.textContent = `Turno: ${playerName}`;
        }

        // --- Resaltar la pieza seleccionada por el humano ---
        function highlightSelectedPiece() {
            // Quitar resaltado anterior de CUALQUIER pieza
            board.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));

            // Solo resaltar si es el turno del humano y hay una pieza seleccionada
            if (selectedPiece && currentPlayer === 'red') {
                const square = board.querySelector(`.square[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col}']`);
                if (square && square.firstChild && square.firstChild.classList.contains('piece')) {
                     square.firstChild.classList.add('selected');
                }
            }
        }

        // --- Resaltar las casillas de posibles movimientos para el humano ---
        function highlightPossibleMoves() {
            // Quitar resaltado de movimientos anteriores de CUALQUIER casilla
            board.querySelectorAll('.possible-move').forEach(s => s.classList.remove('possible-move'));
            board.querySelectorAll('.possible-capture').forEach(s => s.classList.remove('possible-capture'));
            // También quitar los resaltados temporales de la IA por si acaso
             board.querySelectorAll('.ai-move-start, .ai-move-end').forEach(s => s.classList.remove('ai-move-start', 'ai-move-end'));


            // Añadir resaltado a los movimientos actuales si es el turno del humano y hay una pieza seleccionada
            if (currentPlayer === 'red' && selectedPiece) {
                possibleMoves.forEach(move => {
                    const square = board.querySelector(`.square[data-row='${move.endRow}'][data-col='${move.endCol}']`);
                    if (square) {
                         if (move.capturedRow !== null) {
                             square.classList.add('possible-capture'); // Resaltar capturas diferente
                         } else {
                             square.classList.add('possible-move'); // Resaltar movimientos simples
                         }
                    }
                });
            }
        }


        // --- Lógica del movimiento del computador ---
        async function makeComputerMove() {
            console.log("Computador (ETHEREUM) está eligiendo movimiento...");
            updateStatus(); // Actualizar estado a "pensando"

            // La deshabilitación visual del tablero ya se hizo en switchTurn

            const legalMoves = findAllLegalMovesForPlayer('black');

            if (legalMoves.length === 0) {
                console.log("Computador no tiene movimientos legales. Doradas (BITCOIN) ganan!"); // Actualizado
                // El humano gana - la condición de victoria se verificará al final
            } else {
                // --- Lógica de selección de movimiento simple (IA básica) ---
                // Priorizar capturas, luego elegir aleatoriamente
                const possibleCapturesForAI = legalMoves.filter(move => move.capturedRow !== null);
                let chosenMove;

                if (possibleCapturesForAI.length > 0) {
                    // Si hay capturas disponibles, elegir una al azar
                    chosenMove = possibleCapturesForAI[Math.floor(Math.random() * possibleCapturesForAI.length)];
                } else {
                    // Si no hay capturas, elegir un movimiento simple al azar
                     chosenMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                }

                 // --- Ejecutar el movimiento elegido ---
                // console.log(`Computador elige mover de ${chosenMove.startRow},${chosenMove.startCol} a ${chosenMove.endRow},${chosenMove.endCol}`);

                // Opcional: Resaltar visualmente la pieza que se va a mover y el destino
                 const startSquare = board.querySelector(`.square[data-row='${chosenMove.startRow}'][data-col='${chosenMove.startCol}']`);
                 const endSquare = board.querySelector(`.square[data-row='${chosenMove.endRow}'][data-col='${chosenMove.endCol}']`);
                 if (startSquare) startSquare.classList.add('ai-move-start');
                 if (endSquare) endSquare.classList.add('ai-move-end');


                 await new Promise(resolve => setTimeout(resolve, COMPUTER_MOVE_DELAY)); // Pequeño retardo antes de mover

                 if (startSquare) startSquare.classList.remove('ai-move-start');
                 if (endSquare) endSquare.classList.remove('ai-move-end');


                // Mover la pieza en el estado
                let currentPiecePosition = { row: chosenMove.endRow, col: chosenMove.endCol };
                let capturedOccurred = movePiece(chosenMove.startRow, chosenMove.startCol, chosenMove.endRow, chosenMove.endCol, chosenMove.capturedRow, chosenMove.capturedCol); // Corregido typo: move.col -> move.capturedCol


                renderBoard(); // Actualizar la visualización después del primer paso

                // --- Manejar capturas en cadena para el computador ---
                // Bucle para realizar capturas en cadena si son posibles
                while (capturedOccurred) {
                    const nextCaptures = getPossibleCaptures(currentPiecePosition.row, currentPiecePosition.col);

                    if (nextCaptures.length > 0) {
                        // Hay más capturas posibles con esta pieza, realizar una
                        const nextCaptureMove = nextCaptures[Math.floor(Math.random() * nextCaptures.length)]; // Elegir una al azar
                        // console.log(`Computador realiza cadena de captura a ${nextCaptureMove.endRow},${nextCaptureMove.endCol}`);

                         // Opcional: Resaltar visualmente el siguiente paso de la cadena
                         const nextEndSquare = board.querySelector(`.square[data-row='${nextCaptureMove.endRow}'][data-col='${nextCaptureMove.endCol}']`);
                         if(nextEndSquare) nextEndSquare.classList.add('ai-move-end'); // Resaltar destino de captura

                         await new Promise(resolve => setTimeout(resolve, COMPUTER_MOVE_DELAY)); // Retardo entre capturas

                         if(nextEndSquare) nextEndSquare.classList.remove('ai-move-end');

                        capturedOccurred = movePiece(currentPiecePosition.row, currentPiecePosition.col, nextCaptureMove.endRow, nextCaptureMove.endCol, nextCaptureMove.capturedRow, nextCaptureMove.capturedCol); // Corregido typo: move.col -> move.capturedCol
                        currentPiecePosition = { row: nextCaptureMove.endRow, col: nextCaptureMove.endCol }; // Actualizar posición de la pieza - Corregido typo: move.col -> move.endCol

                        renderBoard(); // Actualizar la visualización después de cada captura en cadena

                    } else {
                        // No hay más capturas en cadena
                        capturedOccurred = false; // Salir del bucle
                    }
                }
                console.log("Fin del movimiento del computador.");
            }


            // Fin del turno del computador (después de simple movimiento o cadena completa)
            isComputerThinking = false; // Ya no está pensando
            // La re-habilitación visual del tablero se hace en switchTurn si el juego no ha terminado.

            if (!checkWinCondition()) { // Si el juego no ha terminado
                 switchTurn(); // Cambiar al turno del jugador humano
            } else {
                // El juego terminó, checkWinCondition ya actualizó el estado y deshabilitó el tablero
                boardWrapper.classList.remove('computer-thinking'); // Asegurar que no tenga la clase de pensando
            }
        }


        // --- Verificar condición de victoria ---
        // Devuelve true si el juego ha terminado, false si continúa. Actualiza el statusDisplay if ends.
        function checkWinCondition() {
            let redPieces = 0;
            let blackPieces = 0;

            // Count remaining pieces
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece) {
                        if (piece.includes('red')) {
                            redPieces++;
                        } else { // black piece
                            blackPieces++;
                        }
                    }
                }
            }

            // Check if each player has legal moves left
            const redHasMoves = findAllLegalMovesForPlayer('red').length > 0;
            const blackHasMoves = findAllLegalMovesForPlayer('black').length > 0;


            if (redPieces === 0 || !redHasMoves) {
                // Black wins if Red has no pieces or no legal moves
                statusDisplay.textContent = "¡ETHEREUM (Computador) han ganado!";
                console.log("Juego Terminado: ETHEREUM (Computador) ganaron!");
                // Disable interactions
                boardWrapper.classList.add('computer-thinking');
                return true;
            }

            if (blackPieces === 0 || !blackHasMoves) {
                // Red wins if Black has no pieces or no legal moves
                statusDisplay.textContent = "¡BITCOIN (Tú) has ganado!";
                console.log("Juego Terminado: BITCOIN (Tú) ganaste!");
                 // Disable interactions
                boardWrapper.classList.add('computer-thinking');
                return true;
            }

            // If no one has won and both have moves, the game continues
            return false;
        }


        // --- Event listener for the reset button ---
        resetButton.addEventListener('click', initializeBoard);


        // --- Initialize the game when the page loads ---
        document.addEventListener('DOMContentLoaded', initializeBoard);
    </script>



</body></html>
